interface Prelude where {
infixr 0 $;
infixr 0 $!;
infixr 0 $!!;
infixr 0 $#;
infixr 0 $##;
infixr 0 &;
infixr 3 &&;
infixr 0 &>;
infixl 7 *;
infixl 6 +;
infixr 5 ++;
infixl 6 -;
infixr 9 .;
infix 4 /=;
infix 4 <;
infix 4 <=;
infix 4 =:<<=;
infix 4 =:<=;
infix 4 =:=;
infix 4 ==;
infix 4 >;
infix 4 >=;
infixl 1 >>;
infixl 1 >>=;
infixr 0 ?;
infixl 7 `div`;
infix 4 `elem`;
infixl 7 `mod`;
infix 4 `notElem`;
infixr 0 `seq`;
infixr 2 ||;
data Bool = False | True;
data Char;
data Either a b = Left a | Right b;
data Float;
data IO a;
data IOError = IOError [Char];
data Int;
data Maybe a = Nothing | Just a;
data Ordering = LT | EQ | GT;
type String = [Char];
data Success;
(!!) :: [a] -> Int -> a;
($) :: (a -> b) -> a -> b;
($!) :: (a -> b) -> a -> b;
($!!) :: (a -> b) -> a -> b;
($#) :: (a -> b) -> a -> b;
($##) :: (a -> b) -> a -> b;
(&) :: Success -> Success -> Success;
(&&) :: Bool -> Bool -> Bool;
(&>) :: Success -> a -> a;
(*) :: Int -> Int -> Int;
(+) :: Int -> Int -> Int;
(++) :: [a] -> [a] -> [a];
(-) :: Int -> Int -> Int;
(.) :: (a -> b) -> (c -> a) -> c -> b;
(/=) :: a -> a -> Bool;
(<) :: a -> a -> Bool;
(<=) :: a -> a -> Bool;
(=:<<=) :: a -> a -> Success;
(=:<=) :: a -> a -> Success;
(=:=) :: a -> a -> Success;
(==) :: a -> a -> Bool;
(>) :: a -> a -> Bool;
(>=) :: a -> a -> Bool;
(>>) :: IO a -> IO b -> IO b;
(>>=) :: IO a -> (a -> IO b) -> IO b;
(?) :: a -> a -> a;
PEVAL :: a -> a;
all :: (a -> Bool) -> [a] -> Bool;
and :: [Bool] -> Bool;
any :: (a -> Bool) -> [a] -> Bool;
appendFile :: [Char] -> [Char] -> IO ();
apply :: (a -> b) -> a -> b;
best :: (a -> Success) -> (a -> a -> Bool) -> [a -> Success];
break :: (a -> Bool) -> [a] -> ([a], [a]);
browse :: (a -> Success) -> IO ();
browseList :: [a -> Success] -> IO ();
catch :: IO a -> (IOError -> IO a) -> IO a;
catchFail :: IO a -> IO a -> IO a;
chr :: Int -> Char;
compare :: a -> a -> Ordering;
concat :: [[a]] -> [a];
concatMap :: (a -> [b]) -> [a] -> [b];
cond :: Success -> a -> a;
const :: a -> b -> a;
curry :: ((a, b) -> c) -> a -> b -> c;
div :: Int -> Int -> Int;
doSolve :: Success -> IO ();
done :: IO ();
drop :: Int -> [a] -> [a];
dropWhile :: (a -> Bool) -> [a] -> [a];
either :: (a -> b) -> (c -> b) -> Either a c -> b;
elem :: a -> [a] -> Bool;
ensureNotFree :: a -> a;
ensureSpine :: [a] -> [a];
enumFrom :: Int -> [Int];
enumFromThen :: Int -> Int -> [Int];
enumFromThenTo :: Int -> Int -> Int -> [Int];
enumFromTo :: Int -> Int -> [Int];
error :: [Char] -> a;
failed :: a;
failure :: a -> b -> c;
filter :: (a -> Bool) -> [a] -> [a];
findall :: (a -> Success) -> [a];
findfirst :: (a -> Success) -> a;
flip :: (a -> b -> c) -> b -> a -> c;
foldl :: (a -> b -> a) -> a -> [b] -> a;
foldl1 :: (a -> a -> a) -> [a] -> a;
foldr :: (a -> b -> b) -> b -> [a] -> b;
foldr1 :: (a -> a -> a) -> [a] -> a;
fst :: (a, b) -> a;
getAllValues :: a -> IO [a];
getChar :: IO Char;
getLine :: IO [Char];
getSomeValue :: a -> IO a;
groundNormalForm :: a -> a;
head :: [a] -> a;
id :: a -> a;
ifVar :: a -> b -> b -> b;
if_then_else :: Bool -> a -> a -> a;
inject :: (a -> Success) -> (a -> Success) -> a -> Success;
ioError :: IOError -> IO a;
iterate :: (a -> a) -> a -> [a];
length :: [a] -> Int;
letrec :: a -> a -> Success;
lines :: [Char] -> [[Char]];
lookup :: a -> [(a, b)] -> Maybe b;
map :: (a -> b) -> [a] -> [b];
mapIO :: (a -> IO b) -> [a] -> IO [b];
mapIO_ :: (a -> IO b) -> [a] -> IO ();
max :: a -> a -> a;
maybe :: a -> (b -> a) -> Maybe b -> a;
min :: a -> a -> a;
mod :: Int -> Int -> Int;
negate :: Int -> Int;
negateFloat :: Float -> Float;
normalForm :: a -> a;
not :: Bool -> Bool;
notElem :: a -> [a] -> Bool;
null :: [a] -> Bool;
once :: (a -> Success) -> a -> Success;
or :: [Bool] -> Bool;
ord :: Char -> Int;
otherwise :: Bool;
prim_Int_div :: Int -> Int -> Int;
prim_Int_minus :: Int -> Int -> Int;
prim_Int_mod :: Int -> Int -> Int;
prim_Int_plus :: Int -> Int -> Int;
prim_Int_times :: Int -> Int -> Int;
prim_appendFile :: [Char] -> [Char] -> IO ();
prim_chr :: Int -> Char;
prim_error :: [Char] -> a;
prim_negateFloat :: Float -> Float;
prim_ord :: Char -> Int;
prim_putChar :: Char -> IO ();
prim_readFile :: [Char] -> IO [Char];
prim_readFileContents :: [Char] -> [Char];
prim_show :: a -> [Char];
prim_writeFile :: [Char] -> [Char] -> IO ();
print :: a -> IO ();
putChar :: Char -> IO ();
putStr :: [Char] -> IO ();
putStrLn :: [Char] -> IO ();
readFile :: [Char] -> IO [Char];
repeat :: a -> [a];
replicate :: Int -> a -> [a];
return :: a -> IO a;
reverse :: [a] -> [a];
seq :: a -> b -> b;
sequenceIO :: [IO a] -> IO [a];
sequenceIO_ :: [IO a] -> IO ();
show :: a -> [Char];
showError :: IOError -> [Char];
snd :: (a, b) -> b;
solveAll :: (a -> Success) -> [a -> Success];
solveAll2 :: (a -> Success) -> [a -> Success];
span :: (a -> Bool) -> [a] -> ([a], [a]);
splitAt :: Int -> [a] -> ([a], [a]);
success :: Success;
tail :: [a] -> [a];
take :: Int -> [a] -> [a];
takeWhile :: (a -> Bool) -> [a] -> [a];
try :: (a -> Success) -> [a -> Success];
uncurry :: (a -> b -> c) -> (a, b) -> c;
unknown :: a;
unlines :: [[Char]] -> [Char];
unpack :: (a -> Success) -> a;
until :: (a -> Bool) -> (a -> a) -> a -> a;
unwords :: [[Char]] -> [Char];
unzip :: [(a, b)] -> ([a], [b]);
unzip3 :: [(a, b, c)] -> ([a], [b], [c]);
userError :: [Char] -> IOError;
words :: [Char] -> [[Char]];
writeFile :: [Char] -> [Char] -> IO ();
zip :: [a] -> [b] -> [(a, b)];
zip3 :: [a] -> [b] -> [c] -> [(a, b, c)];
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c];
zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d];
(||) :: Bool -> Bool -> Bool
}