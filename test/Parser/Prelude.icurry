interface Prelude where {
infixr 0 $;
infixr 0 $!;
infixr 0 $!!;
infixr 0 $#;
infixr 0 $##;
infixr 0 &;
infixr 3 &&;
infixr 0 &>;
infixl 7 *;
infixl 6 +;
infixr 5 ++;
infixl 6 -;
infixr 9 .;
infix 4 /=;
infix 4 <;
infix 4 <=;
infix 4 =:<<=;
infix 4 =:<=;
infix 4 =:=;
infix 4 ==;
infix 4 >;
infix 4 >=;
infixl 1 >>;
infixl 1 >>=;
infixr 0 ?;
infixl 7 `div`;
infix 4 `elem`;
infixl 7 `mod`;
infix 4 `notElem`;
infixr 0 `seq`;
infixr 2 ||;
data Bool = False | True;
data Char;
data Either a b = Left a | Right b;
data Float;
data IO a;
data IOError = IOError [Char];
data Int;
data Maybe a = Nothing | Just a;
data Ordering = LT | EQ | GT;
type String = [Char];
data Success;
(!!) 2 :: [a] -> Int -> a;
($) 2 :: (a -> b) -> a -> b;
($!) 2 :: (a -> b) -> a -> b;
($!!) 2 :: (a -> b) -> a -> b;
($#) 2 :: (a -> b) -> a -> b;
($##) 2 :: (a -> b) -> a -> b;
(&) 2 :: Success -> Success -> Success;
(&&) 2 :: Bool -> Bool -> Bool;
(&>) 2 :: Success -> a -> a;
(*) 2 :: Int -> Int -> Int;
(+) 2 :: Int -> Int -> Int;
(++) 2 :: [a] -> [a] -> [a];
(-) 2 :: Int -> Int -> Int;
(.) 2 :: (a -> b) -> (c -> a) -> c -> b;
(/=) 2 :: a -> a -> Bool;
(<) 2 :: a -> a -> Bool;
(<=) 2 :: a -> a -> Bool;
(=:<<=) 2 :: a -> a -> Success;
(=:<=) 2 :: a -> a -> Success;
(=:=) 2 :: a -> a -> Success;
(==) 2 :: a -> a -> Bool;
(>) 2 :: a -> a -> Bool;
(>=) 2 :: a -> a -> Bool;
(>>) 2 :: IO a -> IO b -> IO b;
(>>=) 2 :: IO a -> (a -> IO b) -> IO b;
(?) 2 :: a -> a -> a;
PEVAL 1 :: a -> a;
all 1 :: (a -> Bool) -> [a] -> Bool;
and 0 :: [Bool] -> Bool;
any 1 :: (a -> Bool) -> [a] -> Bool;
appendFile 2 :: [Char] -> [Char] -> IO ();
apply 2 :: (a -> b) -> a -> b;
best 2 :: (a -> Success) -> (a -> a -> Bool) -> [a -> Success];
break 1 :: (a -> Bool) -> [a] -> ([a], [a]);
browse 1 :: (a -> Success) -> IO ();
browseList 1 :: [a -> Success] -> IO ();
catch 2 :: IO a -> (IOError -> IO a) -> IO a;
catchFail 2 :: IO a -> IO a -> IO a;
chr 1 :: Int -> Char;
compare 2 :: a -> a -> Ordering;
concat 1 :: [[a]] -> [a];
concatMap 1 :: (a -> [b]) -> [a] -> [b];
cond 2 :: Success -> a -> a;
const 2 :: a -> b -> a;
curry 3 :: ((a, b) -> c) -> a -> b -> c;
div 2 :: Int -> Int -> Int;
doSolve 1 :: Success -> IO ();
done 0 :: IO ();
drop 2 :: Int -> [a] -> [a];
dropWhile 2 :: (a -> Bool) -> [a] -> [a];
either 3 :: (a -> b) -> (c -> b) -> Either a c -> b;
elem 1 :: a -> [a] -> Bool;
ensureNotFree 1 :: a -> a;
ensureSpine 1 :: [a] -> [a];
enumFrom 1 :: Int -> [Int];
enumFromThen 2 :: Int -> Int -> [Int];
enumFromThenTo 3 :: Int -> Int -> Int -> [Int];
enumFromTo 2 :: Int -> Int -> [Int];
error 1 :: [Char] -> a;
failed 0 :: a;
failure 2 :: a -> b -> c;
filter 2 :: (a -> Bool) -> [a] -> [a];
findall 1 :: (a -> Success) -> [a];
findfirst 1 :: (a -> Success) -> a;
flip 3 :: (a -> b -> c) -> b -> a -> c;
foldl 3 :: (a -> b -> a) -> a -> [b] -> a;
foldl1 2 :: (a -> a -> a) -> [a] -> a;
foldr 3 :: (a -> b -> b) -> b -> [a] -> b;
foldr1 2 :: (a -> a -> a) -> [a] -> a;
fst 1 :: (a, b) -> a;
getAllValues 1 :: a -> IO [a];
getChar 0 :: IO Char;
getLine 0 :: IO [Char];
getSomeValue 1 :: a -> IO a;
groundNormalForm 1 :: a -> a;
head 1 :: [a] -> a;
id 1 :: a -> a;
ifVar 3 :: a -> b -> b -> b;
if_then_else 3 :: Bool -> a -> a -> a;
inject 2 :: (a -> Success) -> (a -> Success) -> a -> Success;
ioError 1 :: IOError -> IO a;
iterate 2 :: (a -> a) -> a -> [a];
length 1 :: [a] -> Int;
letrec 2 :: a -> a -> Success;
lines 1 :: [Char] -> [[Char]];
lookup 2 :: a -> [(a, b)] -> Maybe b;
map 2 :: (a -> b) -> [a] -> [b];
mapIO 1 :: (a -> IO b) -> [a] -> IO [b];
mapIO_ 1 :: (a -> IO b) -> [a] -> IO ();
max 2 :: a -> a -> a;
maybe 3 :: a -> (b -> a) -> Maybe b -> a;
min 2 :: a -> a -> a;
mod 2 :: Int -> Int -> Int;
negate 1 :: Int -> Int;
negateFloat 1 :: Float -> Float;
normalForm 1 :: a -> a;
not 1 :: Bool -> Bool;
notElem 1 :: a -> [a] -> Bool;
null 1 :: [a] -> Bool;
once 1 :: (a -> Success) -> a -> Success;
or 0 :: [Bool] -> Bool;
ord 1 :: Char -> Int;
otherwise 0 :: Bool;
prim_Int_div 2 :: Int -> Int -> Int;
prim_Int_minus 2 :: Int -> Int -> Int;
prim_Int_mod 2 :: Int -> Int -> Int;
prim_Int_plus 2 :: Int -> Int -> Int;
prim_Int_times 2 :: Int -> Int -> Int;
prim_appendFile 2 :: [Char] -> [Char] -> IO ();
prim_chr 1 :: Int -> Char;
prim_error 1 :: [Char] -> a;
prim_negateFloat 1 :: Float -> Float;
prim_ord 1 :: Char -> Int;
prim_putChar 1 :: Char -> IO ();
prim_readFile 1 :: [Char] -> IO [Char];
prim_readFileContents 1 :: [Char] -> [Char];
prim_show 1 :: a -> [Char];
prim_writeFile 2 :: [Char] -> [Char] -> IO ();
print 1 :: a -> IO ();
putChar 1 :: Char -> IO ();
putStr 1 :: [Char] -> IO ();
putStrLn 1 :: [Char] -> IO ();
readFile 1 :: [Char] -> IO [Char];
repeat 1 :: a -> [a];
replicate 2 :: Int -> a -> [a];
return 1 :: a -> IO a;
reverse 0 :: [a] -> [a];
seq 2 :: a -> b -> b;
sequenceIO 1 :: [IO a] -> IO [a];
sequenceIO_ 0 :: [IO a] -> IO ();
show 1 :: a -> [Char];
showError 1 :: IOError -> [Char];
snd 1 :: (a, b) -> b;
solveAll 1 :: (a -> Success) -> [a -> Success];
solveAll2 1 :: (a -> Success) -> [a -> Success];
span 2 :: (a -> Bool) -> [a] -> ([a], [a]);
splitAt 2 :: Int -> [a] -> ([a], [a]);
success 0 :: Success;
tail 1 :: [a] -> [a];
take 2 :: Int -> [a] -> [a];
takeWhile 2 :: (a -> Bool) -> [a] -> [a];
try 1 :: (a -> Success) -> [a -> Success];
uncurry 2 :: (a -> b -> c) -> (a, b) -> c;
unknown 0 :: a;
unlines 1 :: [[Char]] -> [Char];
unpack 1 :: (a -> Success) -> a;
until 3 :: (a -> Bool) -> (a -> a) -> a -> a;
unwords 1 :: [[Char]] -> [Char];
unzip 1 :: [(a, b)] -> ([a], [b]);
unzip3 1 :: [(a, b, c)] -> ([a], [b], [c]);
userError 1 :: [Char] -> IOError;
words 1 :: [Char] -> [[Char]];
writeFile 2 :: [Char] -> [Char] -> IO ();
zip 2 :: [a] -> [b] -> [(a, b)];
zip3 3 :: [a] -> [b] -> [c] -> [(a, b, c)];
zipWith 3 :: (a -> b -> c) -> [a] -> [b] -> [c];
zipWith3 4 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d];
(||) 2 :: Bool -> Bool -> Bool
}
interfaceTypeClasses Prelude where {
infixr 0 $;
infixr 0 $!;
infixr 0 $!!;
infixr 0 $#;
infixr 0 $##;
infixr 0 &;
infixr 3 &&;
infixr 0 &>;
infixl 7 *;
infixl 6 +;
infixr 5 ++;
infixl 6 -;
infixr 9 .;
infix 4 /=;
infix 4 <;
infix 4 <=;
infix 4 =:<<=;
infix 4 =:<=;
infix 4 =:=;
infix 4 ==;
infix 4 >;
infix 4 >=;
infixl 1 >>;
infixl 1 >>=;
infixr 0 ?;
infixl 7 `div`;
infix 4 `elem`;
infixl 7 `mod`;
infix 4 `notElem`;
infixr 0 `seq`;
infixr 2 ||;
data Bool = False | True;
data Char;
data Either a b = Left a | Right b;
data Float;
data IO a;
data IOError = IOError [Char];
data Int;
data Maybe a = Nothing | Just a;
data Ordering = LT | EQ | GT;
type String = [Char];
data Success;
(!!) 2 :: [a] -> Int -> a;
($) 2 :: (a -> b) -> a -> b;
($!) 2 :: (a -> b) -> a -> b;
($!!) 2 :: (a -> b) -> a -> b;
($#) 2 :: (a -> b) -> a -> b;
($##) 2 :: (a -> b) -> a -> b;
(&) 2 :: Success -> Success -> Success;
(&&) 2 :: Bool -> Bool -> Bool;
(&>) 2 :: Success -> a -> a;
(*) 2 :: Int -> Int -> Int;
(+) 2 :: Int -> Int -> Int;
(++) 2 :: [a] -> [a] -> [a];
(-) 2 :: Int -> Int -> Int;
(.) 2 :: (a -> b) -> (c -> a) -> c -> b;
(/=) 2 :: a -> a -> Bool;
(<) 2 :: a -> a -> Bool;
(<=) 2 :: a -> a -> Bool;
(=:<<=) 2 :: a -> a -> Success;
(=:<=) 2 :: a -> a -> Success;
(=:=) 2 :: a -> a -> Success;
(==) 2 :: a -> a -> Bool;
(>) 2 :: a -> a -> Bool;
(>=) 2 :: a -> a -> Bool;
(>>) 2 :: IO a -> IO b -> IO b;
(>>=) 2 :: IO a -> (a -> IO b) -> IO b;
(?) 2 :: a -> a -> a;
PEVAL 1 :: a -> a;
all 1 :: (a -> Bool) -> [a] -> Bool;
and 0 :: [Bool] -> Bool;
any 1 :: (a -> Bool) -> [a] -> Bool;
appendFile 2 :: [Char] -> [Char] -> IO ();
apply 2 :: (a -> b) -> a -> b;
best 2 :: (a -> Success) -> (a -> a -> Bool) -> [a -> Success];
break 1 :: (a -> Bool) -> [a] -> ([a], [a]);
browse 1 :: (a -> Success) -> IO ();
browseList 1 :: [a -> Success] -> IO ();
catch 2 :: IO a -> (IOError -> IO a) -> IO a;
catchFail 2 :: IO a -> IO a -> IO a;
chr 1 :: Int -> Char;
compare 2 :: a -> a -> Ordering;
concat 1 :: [[a]] -> [a];
concatMap 1 :: (a -> [b]) -> [a] -> [b];
cond 2 :: Success -> a -> a;
const 2 :: a -> b -> a;
curry 3 :: ((a, b) -> c) -> a -> b -> c;
div 2 :: Int -> Int -> Int;
doSolve 1 :: Success -> IO ();
done 0 :: IO ();
drop 2 :: Int -> [a] -> [a];
dropWhile 2 :: (a -> Bool) -> [a] -> [a];
either 3 :: (a -> b) -> (c -> b) -> Either a c -> b;
elem 1 :: a -> [a] -> Bool;
ensureNotFree 1 :: a -> a;
ensureSpine 1 :: [a] -> [a];
enumFrom 1 :: Int -> [Int];
enumFromThen 2 :: Int -> Int -> [Int];
enumFromThenTo 3 :: Int -> Int -> Int -> [Int];
enumFromTo 2 :: Int -> Int -> [Int];
error 1 :: [Char] -> a;
failed 0 :: a;
failure 2 :: a -> b -> c;
filter 2 :: (a -> Bool) -> [a] -> [a];
findall 1 :: (a -> Success) -> [a];
findfirst 1 :: (a -> Success) -> a;
flip 3 :: (a -> b -> c) -> b -> a -> c;
foldl 3 :: (a -> b -> a) -> a -> [b] -> a;
foldl1 2 :: (a -> a -> a) -> [a] -> a;
foldr 3 :: (a -> b -> b) -> b -> [a] -> b;
foldr1 2 :: (a -> a -> a) -> [a] -> a;
fst 1 :: (a, b) -> a;
getAllValues 1 :: a -> IO [a];
getChar 0 :: IO Char;
getLine 0 :: IO [Char];
getSomeValue 1 :: a -> IO a;
groundNormalForm 1 :: a -> a;
head 1 :: [a] -> a;
id 1 :: a -> a;
ifVar 3 :: a -> b -> b -> b;
if_then_else 3 :: Bool -> a -> a -> a;
inject 2 :: (a -> Success) -> (a -> Success) -> a -> Success;
ioError 1 :: IOError -> IO a;
iterate 2 :: (a -> a) -> a -> [a];
length 1 :: [a] -> Int;
letrec 2 :: a -> a -> Success;
lines 1 :: [Char] -> [[Char]];
lookup 2 :: a -> [(a, b)] -> Maybe b;
map 2 :: (a -> b) -> [a] -> [b];
mapIO 1 :: (a -> IO b) -> [a] -> IO [b];
mapIO_ 1 :: (a -> IO b) -> [a] -> IO ();
max 2 :: a -> a -> a;
maybe 3 :: a -> (b -> a) -> Maybe b -> a;
min 2 :: a -> a -> a;
mod 2 :: Int -> Int -> Int;
negate 1 :: Int -> Int;
negateFloat 1 :: Float -> Float;
normalForm 1 :: a -> a;
not 1 :: Bool -> Bool;
notElem 1 :: a -> [a] -> Bool;
null 1 :: [a] -> Bool;
once 1 :: (a -> Success) -> a -> Success;
or 0 :: [Bool] -> Bool;
ord 1 :: Char -> Int;
otherwise 0 :: Bool;
prim_Int_div 2 :: Int -> Int -> Int;
prim_Int_minus 2 :: Int -> Int -> Int;
prim_Int_mod 2 :: Int -> Int -> Int;
prim_Int_plus 2 :: Int -> Int -> Int;
prim_Int_times 2 :: Int -> Int -> Int;
prim_appendFile 2 :: [Char] -> [Char] -> IO ();
prim_chr 1 :: Int -> Char;
prim_error 1 :: [Char] -> a;
prim_negateFloat 1 :: Float -> Float;
prim_ord 1 :: Char -> Int;
prim_putChar 1 :: Char -> IO ();
prim_readFile 1 :: [Char] -> IO [Char];
prim_readFileContents 1 :: [Char] -> [Char];
prim_show 1 :: a -> [Char];
prim_writeFile 2 :: [Char] -> [Char] -> IO ();
print 1 :: a -> IO ();
putChar 1 :: Char -> IO ();
putStr 1 :: [Char] -> IO ();
putStrLn 1 :: [Char] -> IO ();
readFile 1 :: [Char] -> IO [Char];
repeat 1 :: a -> [a];
replicate 2 :: Int -> a -> [a];
return 1 :: a -> IO a;
reverse 0 :: [a] -> [a];
seq 2 :: a -> b -> b;
sequenceIO 1 :: [IO a] -> IO [a];
sequenceIO_ 0 :: [IO a] -> IO ();
show 1 :: a -> [Char];
showError 1 :: IOError -> [Char];
snd 1 :: (a, b) -> b;
solveAll 1 :: (a -> Success) -> [a -> Success];
solveAll2 1 :: (a -> Success) -> [a -> Success];
span 2 :: (a -> Bool) -> [a] -> ([a], [a]);
splitAt 2 :: Int -> [a] -> ([a], [a]);
success 0 :: Success;
tail 1 :: [a] -> [a];
take 2 :: Int -> [a] -> [a];
takeWhile 2 :: (a -> Bool) -> [a] -> [a];
try 1 :: (a -> Success) -> [a -> Success];
uncurry 2 :: (a -> b -> c) -> (a, b) -> c;
unknown 0 :: a;
unlines 1 :: [[Char]] -> [Char];
unpack 1 :: (a -> Success) -> a;
until 3 :: (a -> Bool) -> (a -> a) -> a -> a;
unwords 1 :: [[Char]] -> [Char];
unzip 1 :: [(a, b)] -> ([a], [b]);
unzip3 1 :: [(a, b, c)] -> ([a], [b], [c]);
userError 1 :: [Char] -> IOError;
words 1 :: [Char] -> [[Char]];
writeFile 2 :: [Char] -> [Char] -> IO ();
zip 2 :: [a] -> [b] -> [(a, b)];
zip3 3 :: [a] -> [b] -> [c] -> [(a, b, c)];
zipWith 3 :: (a -> b -> c) -> [a] -> [b] -> [c];
zipWith3 4 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d];
(||) 2 :: Bool -> Bool -> Bool
}